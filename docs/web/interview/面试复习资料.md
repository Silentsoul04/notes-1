# 笔试

## 逻辑笔试

#### 1. 在临上刑场前，国王对预言家说：“你不是很会预言吗？你怎么不能预言到你今天要被处死呢？我给你一个机会，你可以预言一下今天我将如何处死你。你如果预言对了，我就让你服毒死；否则，我就绞死你。” 但是聪明的预言家的回答，使得国王无论如何也无法将他处死。

#### 2. 三个箱子，一箱是苹果，一箱是橘子，一箱是两种水果的混装，三个箱子都贴上了标签，但所有的标签都贴错了，现在你只拿出一个水果来判断3个箱子里的情况

## 技术笔试

### 1. 谈谈你对MVVM的理解

MVVM 是 Model-View-ViewModel 的简写，即模型-视图-视图模型。MVVM最早由微软的工程师提出来的，它借鉴了MVC的思想；在前端项目中，Model用纯 JavaScript 对象表示，View负责页面视图，两者做到了最大限度的分离。把 Model 和 View 关联起来的就是 ViewModel。ViewModel 负责把 Model 的数据同步到 View 显示出来，同时还负责把View的修改同步回Model。

【模型】到【视图】的转化，实现方式是数据绑定；【视图】到【模型】的转化，实现方式是 DOM 事件监听。两个方向都实现了的，我们称之为双向绑定。Vue 双向绑定的核心是数据劫持，Angular 双向绑定的核心是脏检查，React 是单向数据流，实现了【模型】影响【视图】。

### 2. 谈谈你对双向绑定的理解

如上题所述，【模型】到【视图】的转化，实现方式是数据绑定；【视图】到【模型】的转化，实现方式是 DOM 事件监听。两个方向都实现了的，我们称之为双向绑定。

目前三大框架中，Vue和Angular是实现了双向绑定的。Vue 双向绑定的核心是数据劫持，Angular 双向绑定的核心是脏检查，Vue2实现数据劫持用的是 Object.defineProperty() ，Vue3 改成了Proxy。

### 3. Vue组件通信方式和实现

1. `props/emit` --- 父组件通过属性向子组件传入，子组件通过 props 接收父组件的传入；子组件通过 emit 向外触发事件向外抛出数据，父组件通过事件监听实现数据接收，props 还可以传递父组件的方法，子组件通过调用父组件的方法将数据传出去 --- 原理：应该是发布订阅
2. `$attrs/emit` --- 与前一个方式基本相同，父组件通过属性向子组件传入，子组件不通过 props 接收，此时父组件传递的数据，子组件可以通过 this.$attrs 来获取
3. `$refs` --- 父组件通过给子组件设置 ref ，获取子组件的实例，通过调用子组件实例上的方法实现数据传输
4. `$parent/$children` --- 子组件通过 \$parent 获取父组件的实例，通过操作父组件来实现数据传出（比如调用父组件的方法）；父组件通过 \$children 获取子组件实例，通过操作实例实现数据传入，需要注意的是 $children 获取的是当前父组件下所有子组件的实例集合
5. `eventBus` --- 通过 on 监听另一个组件发布的事件，另一个组件通过 emit 发布事件，来实现数据传递 --- 原理：发布订阅
6. `Vuex` --- Vue官方的状态管理仓库，核心原理是 单例模式 + 发布订阅模式，单例模式的作用是使所有组件可以共享同一个状态库，发布订阅的作用是 使组件间通过发布事件的方式实现数据流动。项目中很常用，但一两句话暂无法描述清楚使用过程
7. `$root` --- 这个方法是间接的实现数据传递，$root 是 Vue 跟组件的实例，一个组件将自身的方法挂载到跟组件实例上，这个方法的作用是取当前组件的某些数据；另一组件通过调用跟实例上的这个方法，来获取数据。
8. 自行写一个发布订阅模式实现数据传递

### 4. 谈谈你对闭包的理解

1. 简单来说闭包就是一个函数的返回值是一个函数
2. 闭包的最大的优点即 避免了定义过多的全局变量造成变量冲突
3. 函数节流和函数防抖就是闭包的典型应用场景；在插件开发中闭包的使用率也非常高

> 笔试题有8道，另外4题想不起来了

# 面试

### 1. Vue的双向绑定（或者说响应式）是怎么实现的

首先双向绑定指的是 Model《==》View 的双向影响，其中 View 到 Model 的改变是通过 DOM 事件监听实现的，Model 到 View 的改变是通过数据绑定实现的，只有两个方向都实现了，才称之为双向绑定。 **先聊概念**

在 Vue 中 View 到 Model 的改变也是通过 DOM 事件监听实现的，但数据绑定是通过数据劫持来实现的，在 Vue2.x 中，数据劫持核心使用的是 Object.defineProperty() ，Vue3 改成了Proxy。像大多数人描述双向绑定都谈到了 Object.defineProperty() ，但其实他只是双向绑定中数据绑定的一部分，很少有人会说到 DOM 监听。**想办法在这里装个逼**

DOM 事件监听和数据劫持是怎么起作用的呢，首先 Vue2.x 的 API 都是 options API，当我们 new Vue 生成 Vue 实例的时候，是需要给 Vue 构造函数传入参数的，这个参数里有一个 el 和 data 属性，当参数传入后 Vue 会先做模板解析。

模板解析会先取 el ，获取到根元素，再获取根元素的子元素，如果子元素还有子元素，会进行递归解析，如果子元素不再有子元素，Vue 会进行正则匹配，将插值表达式的数据替换成 data 中的数据，同时这个时候是有这个元素的实例的，会给这个子元素设置事件监听，这个事件监听是用 发布订阅模式实现的，同时这个监听分为两方面，一个是监听这个元素所依赖的数据被改变时发布的事件，监听到之后，通过元素实例修改元素内容；另一个是监听这个元素的 input、change这些事件，当这些事件触发时，Vue 会向外发布事件，通知这个数据被改了。这是模板解析过程。

模板解析后会对data进行解析劫持，首先对 data 进行遍历，如果 data 的子属性还是个 对象，会对其进行递归遍历，如果不是对象，就会将这个对象（这个对象不一定是 data，有可能是data的属性对象）和 key，传给 Object.defineProperty() ，让其去代理这个对象的这个属性，同时给 Object.defineProperty() 传入第三个参数，第三个参数是一个对象，这个对象中要去设置个 get 和 set 方法，当用户获取这个对象的这个属性或者修改时，就会触发 get 和 set 方法，我们需要在 set 方法中去发布事件和监听事件，当这个属性被修改时，我们去发布事件，通知模板解析中元素实例设置数据监听方法，好让页面更新，同时监听元素 input、change 后发布的事件，好使的页面改变的时候，数据同步会 model。

但这只是一个核心的实现思路，在 Vue 的源码中，Vue 是做了相当多的工作的，像对于 Vue 指令的解析，插值表达式中的函数调用，v-bind的解析，以及指令等可能不在最内层元素上的解析，还有像对于数组的劫持，因为 Object.defineProperty() 只能劫持对象，我这块表述的其实只能算是Vue双向绑定的冰山一角。**这段是关键，上面的实现思路其实非常浅，而且还留了非常多的可发问的余地，这段先谦虚，说出自己表述没考虑的地方，表现不足，避免面试官往深的问，同时再隐含的表述自己看过源码。总之很关键**

### 2. 你刚才说了 Object.defineProperty() 只能劫持对象，那 Vue 中对于数组是怎么实现劫持的。

我了解道的 Vue 对数组的 push、pop、shift 等会影响数组的方法，进行了重写，当是用 push 等方法时，会调用 Vue 重写的方法，Vue 在这些方法内做了拦截。但如果直接通过索引去修改数组元素，Vue 也拦截不到，如果想要通过索引修改数组元素，好像需要调用 \$next 或者 $set 方法，项目中很少使用索引去修改数组，这块记得不是很清楚。

### 3. Vue3中对于数据劫持由 Object.defineProperty() 改成了 proxy，它俩有什么区别

1. Object.defineProperty() 是 ES5 新加的 API，在IE8及以下的浏览器并不支持；proxy 是 ES6 新增的对象，所有版本的IE浏览器都不支持至今
2. Object.defineProperty() 只能对Object进行代理，且代理的是对象的属性，且只能代理通过字面量设置了代理的对象属性，所以在 Vue2.x 中，对于在 data 中，没有定义的属性，无法进行响应式；proxy 可以代理 Object, Array, Symbol, String 等多种数据格式，对于对象的属性无需显示设置，会代理对象上所有的属性，哪怕是后来添加的。如果对象的属性还是对象，对于深层次的代理，仍需递归设置。

### 4. 你简历有些熟悉Vue插件开发，你是怎么进行插件开发的？

首先对于 Vue 的插件我们是通过 Vue.use 方法来进行使用的，那么我们就需要对 Vue.use 有所了解，Vue.use 需要一个参数，这个参数可以是对象也可以是个函数，如果是对象，那么这个对象必须拥有一个 install 方法，Vue.use 会调用这个 install 方法，然后将 Vue 传进去。

开发插件就是将我们所要做的封装起来，或者封装成函数，或者封装成对象，最后这个封装起来的东西挂到 Vue 上，这样在 Vue 就可以使用插件。

挂到 Vue 的方法有多种，可以通过 prototype 挂到 Vue 原型上，也可以通过全局混入的方式挂到之后每个被创建的组件上。像 Vuex 就是通过混入的方式加到所有组件上的。

### 5. 你简历有写熟悉 VueX，Vue-router的实现原理，能简单说下吗

首先对于 Vuex 我们需要了解他解决的问题是什么，无论是在 Vuex 中，还是 React 中，我们都需要状态管理。比如一个组件需要使用另一个组件或多个组件的状态，或者一个组件需要改变另一个组件或多个组件的状态，这个时候我们就需要把这些状态独立出来，去共享，使所有的组件都可以使用。这些状态很多时候在代码里是通过数据的改变来实现的，所以也叫数据仓库。

所以我们需要做的就是对这些状态进行合理的管理，在软件开发里，有些通用的思想，比如隔离变化，约定优于配置等，隔离变化就是说做好抽象，把一些容易变化的地方找到共性，隔离出来，不要去影响其他的代码。约定优于配置就是很多东西我们不一定要写一大堆的配置，比如我们几个人约定，view 文件夹里只能放视图，不能放过滤器，过滤器必须放到 filter 文件夹里，那这就是一种约定，约定好之后，我们就不用写一大堆配置文件了，我们要找所有的视图，直接从 view 文件夹里找就行。

根据这些思想，对于状态管理的解决思路就是：**把组件之间需要共享的状态抽取出来，遵循特定的约定，统一来管理，让状态的变化可以预测**。

一个很简单的方法就是将这些状态存到一个外部变量中，或者全局变量中，总之这个变量需要让所有的组件都可以访问到。但这样有一个问题，就是所有组件都可以在自己的地方去对这个数据进行改变，没有集中管理，比较分散；另一个问题是，数据改变后，不会留下变更过的记录，调试不方便，开发也不友好。

所以我们就需要做一些约定，在 Vuex 中，我们约定 state 中存放共享的数据，数据如果要被改变，必须先通过 dispatch 派发改变需求到 action ，让 action 通过 commit 提交到 mutation，由 mutation 去做最后的修改，这样每一个数据的修改，都是通过我们约定好的流程进行的，每一步的改变都有迹可循。

但是到这里有一个很关键的点我们没有说，当 state 中的数据被修改的时候，我们的组件状态也要改变，对于这个我们可以依旧采用数据劫持的思想，在做次拦截，让组件去监听改变的事件。在 Vuex 中，这块依赖了 Vue 中的数据劫持，state 中的数据通过 $store 混入了组件的 state，由 Vue 去做劫持了，所以也使得 Vuex 只能在 Vue 中使用。

---

Vue-router 是做前端路由的，它有两种模式，hash 和 history 模式。

hash 模式没太多可说的，核心原理就是 # 后面的内容修改，不会造成页面刷新，然后监听 hashChange 事件，监听到对于事件后获取路由，做对应渲染。

关键是 history 模式，hash 模式用 # 毕竟很丑，history 就看起来好多了，但正常来说这种形式的 url 改变，必然会造成浏览器重新去服务器加载请求，也就是说页面会闪，但我们在应用过程中实际并没有发生闪的情况。核心就是 history.pushState() 和 history.replaceState() API，push 会在历史记录顶层在添加一条记录，replace 会替换当前的历史记录，这两个API的共同特点是当调用他们修改浏览器历史记录栈后，虽然当前URL改变了，但浏览器不会立即发送请求。同时通过这俩API去做url修改，会触发 popstate ，通过监听这个事件，去做对应的视图渲染。

> 但还有点是：如果直接在浏览器属于地址，浏览器会向服务器发出请求，但服务器根本没有这个地址的文件，所以会报404，这就需要我们对 nginx 做对应配置，如果 url 不存在，就还是返回这个单页面。

> router-view 就相当于一个容器，当路由匹配到之后，会将对应的组件填充到 router-view 中
>
> router-link 就是封了个组件，当被点击的时候调用 router 的 API 做跳转

### 6. 你对devOps是怎么理解的

DevOps 一词的来自于 Development 和 Operations 的组合，突出重视软件开发人员和运维人员的沟通合作，通过自动化流程来使得软件构建、测试、发布更加快捷、频繁和可靠。DevOps 其实包含了三个部分：开发、测试和运维。换句话 DevOps 希望做到的是软件产品交付过程中IT工具链的打通，使得各个团队减少时间损耗，更加高效地协同工作。

它由一系列的工具组成，像项目管理工具，我们用过明道、蝉道，jria，目前用的是teambition，代码管理用的是公司自己搭的 gitlab，使用 Docker 进行容器管理，以及使用 jenkins 进行自动化部署，当然这条链上的工具很多，但更多的是由运维在打交道。

> 缺少自动化测试，想办法编

![img](https://static.jindll.com/notes/1190892-20170711181750743-1188576503.png)

### 7. 聊一下 git-flow 工作流程？你们团队中是怎么进行git管理的？

git-flow 是一套git管理流程，他的形式有多种，比较经典的模型是：

1. Master分支，这个分支负责发布生产环境的代码，最近发布的Release， 这个分支只能从其他分支合并，不能在这个分支直接修改；这个分支的每一次 commit 都应该打 tag
2. Develop 分支，这个分支是我们是我们的主开发分支，包含所有要发布到下一个Release的代码，这个主要合并与其他分支，比如Feature分支
3. Feature 分支，这个分支主要是用来开发一个新的功能，一旦开发完成，我们合并回Develop分支进入下一个Release
4. Release分支，当你需要一个发布一个新Release的时候，我们基于Develop分支创建一个Release分支，完成Release后，我们合并到Master和Develop分支
5. Hotfix分支，当我们在Production发现新的Bug时候，我们需要创建一个Hotfix, 完成Hotfix后，我们合并回Master和Develop分支，所以Hotfix的改动会进入下一个Release

### 8. webpack性能优化你都做过哪些工作

两个方面，提高打包速度，减小打包体积

打包速度：

1. 第三方依赖通过 CDN 的方式挂载，不要通过 npm install

2. 使用路径别名，避免过多的使用相对路径（路径别名相当于绝对路径，如果使用相对路径，webpack 打包必须根据相对路径一层一层去查找文件）

3. 导入的模块文件添加后缀，不带的后缀的，通过webpack配置文件类型查找的优先级，常用的放前面，比如 `.vue` `.js` `.css` 配置在前面

4. 配置不需要被解析的模块，例如 node_modules 就不需要被打包编译

5. 借助 `webpack.DllPlugin` 插件进行预编译

6. 使用插件开启多线程打包和开启 babel 的缓存

减小体积：

1. CDN
2. 代码压缩
3. 静态资源放 OSS，小图标可以使用iconfont

### 9. 前端性能优化的方法都有哪些

1. CDN
2. 资源打包压缩：代码压缩、雪碧图
3. 非核心代码异步加载，给 script 标签添加 defer 和 async 属性
4. 使用缓存
5. DNS预解析

### 10. 对于一个大型项目你是考虑设计的

### 11. 你在项目开发中遇到过那些问题，你是如何解决的

### 12. 你离职的原因是什么

> 不要说前一家公司的坏话，不要说因为工资低；

# 其他可能问到的问题

### 1. 你用过那些新版ESAPI

### 2. var、const、let的区别

### 3. 箭头函数与function的区别

### 4. JS模块化

### 5. 跨域

# 腾讯面试还可能问到的问题

### 1. 浏览器输入URL后发生了什么

### 2. DNS解析过程

### 3. TCP连接过程

### 4. http/https工作原理

### 5. 浏览器对于HTML解析渲染过程

### 6. JS代码执行过程

### 7. EventLoop

### 8. JS继承，原型链

### 9. Vue的虚拟DOM

### 10. new Vue后发生了什么

### 11. Web安全

