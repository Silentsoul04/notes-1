---
title: 对象
---

## is

* 此API为ES6新增API
* `Object.is()` 方法判断两个值是否是[相同的值](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Equality_comparisons_and_sameness)。
* 在ES6之前判断两个值是否相等只有`==`和`===`,现在我们多了个选择可以使用`Object.is()`
* 语法：`Object.is(value1, value2);`
  * `value1` 第一个需要比较的值
  * `value2` 第二个需要比较的值
  * 返回值 表示比较结果的布尔值

```js
const obj1 = {name: '张三'};
console.log(Object.is(obj1, {name: '张三'})); // false
console.log(obj1 === {name: '张三'}); // false
console.log(obj1 == {name: '张三'}); // false

console.log(Object.is(obj1, obj1)); // true
console.log(obj1 === obj1); // true
console.log(obj1 == obj1); // true

const num1 = +0;
console.log(Object.is(num1, -0)); // false
console.log(num1 === -0); // true
console.log(num1 == -0); // true
```

> 补充：js对于引用类型的比较实质是内存地址的比较，而不是内容的比较；对于原始类型的比较是值得比较
>
> 其实`Object.is()` 基本和`===` 是一样的，不同的地方就是：一是`+0`不等于`-0`（在`===`中 `+0 === -0`是true），二是`NaN`等于自身（在`===`中 `NaN === NaN`是false）
>
>  `==` 的比较会先进行类型转换再进行比较，而`===` 不会。这两区别在最开始学习js的时候应该是有进行了解的 

## assign

* 此API是ES6新增的API
* `assign()` 用于将一个或多个对象的可枚举属性拷贝到目标对象，并返回目标对象
* `assign()` 简单讲就是多个对象合并，但如果目标对象（要合入的对象）和来源对象（拷贝来源对象的属性粘贴到目标对象）有相同的key，则来源对象的key会覆盖目标对象的key，来源对象后面还有若干个来源对象，则后面的会覆盖前面的。
* 该操作会修改目标对象
*  `Object.assign()`拷贝的是属性值。假如源对象的属性值是一个对象的引用，那么它也只指向那个引用
* 语法：`Object.assign(target, ...sources)`
  - `target` 目标对象
  - `sources` 源对象
  - 返回值 目标对象

```js
const target = {name: '李白', id: 1098};
const sources1 = {sexCode: 1, age: 99, id: 1010};
const sources2 = {name: '杜甫', id: 1209, height: 170};

const result = Object.assign(target,sources1,sources2);
console.log(result); // { name: "杜甫", id: 1209, sexCode: 1, age: 99, height: 170 } 源对象与目标对象相同的key 后者会覆盖前者
console.log(target); // { name: "杜甫", id: 1209, sexCode: 1, age: 99, height: 170 } assign 会修改目标对象
console.log(sources1); // { sexCode: 1, age: 99, id: 1010 }
console.log(sources2); // { name: "杜甫", id: 1209, height: 170 }
```

```js
const sources1 = {sexCode: 1, age: 99, id: 1010};
const sources2 = {name: '杜甫', id: 1209, height: 170};
const sources3 = {sources: sources2};
const result2 = Object.assign(sources1,sources2,sources3);
console.log(result2);
// 输出 { sexCode: 1, age: 99, id: 1209, name: "杜甫", height: 170, sources: Object { name: "杜甫", id: 1209, height: 170 } }
sources2.weight = '68kg';
console.log(result2);
// 输出 { sexCode: 1, age: 99, id: 1209, name: "杜甫", height: 170, sources: Object { name: "杜甫", id: 1209, height: 170, weight: "68kg" } }
console.log(sources2);
// 输出 { name: "杜甫", id: 1209, height: 170, weight: "68kg" }
console.log(sources3);
// 输出 { sources: Object { name: "杜甫", id: 1209, height: 170, weight: "68kg" } }
```

> `sources3` 对象的`sources` 属性是引用的`sources2` 对象，所以`sources2` 对象被修改，`sources3` 的`sources` 的值就会同步被修改。
>
> `sources1` 对象将`sources3` 对象的`sources` 属性拷贝进去了，`sources3` 对象的`sources` 引用的是`sources2` 对象，**所以** ，最终也就是`sources1`对象`sources` 也引用了`sources2` 对象，所以`sources2` 修改的同时，所有引用了它的（对象），都会被修改

```js
const sources = {sexCode: 1, id: 1010};
Object.defineProperty(sources, 'age', {
  enumerable: false,
  value: 99,
});
console.log(sources); // 输出 {sexCode: 1, id: 1010, age: 99}
const result = Object.assign({},sources);
console.log(result); // 输出 {sexCode: 1, id: 1010}
```

> `sources` 是源对象，我们给其设置了一个`age` 的不可枚举属性，使用`assign()` API 将其合并入一个空数组，由于`age` 属性是不可枚举的，所以`age` 并没有被`assign()`进行拷贝

> **此API在IE浏览器不支持，如果需要兼容IE浏览器，可以在js顶部添加如下代码；（[如下代码来自MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)）**
>
> ```js
> if (typeof Object.assign != 'function') {
>   // Must be writable: true, enumerable: false, configurable: true
>   Object.defineProperty(Object, "assign", {
>     value: function assign(target, varArgs) { // .length of function is 2
>       'use strict';
>       if (target == null) { // TypeError if undefined or null
>         throw new TypeError('Cannot convert undefined or null to object');
>       }
> 
>       let to = Object(target);
> 
>       for (var index = 1; index < arguments.length; index++) {
>         var nextSource = arguments[index];
> 
>         if (nextSource != null) { // Skip over if undefined or null
>           for (let nextKey in nextSource) {
>             // Avoid bugs when hasOwnProperty is shadowed
>             if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
>               to[nextKey] = nextSource[nextKey];
>             }
>           }
>         }
>       }
>       return to;
>     },
>     writable: true,
>     configurable: true
>   });
> }
> ```

## keys

- `Object.keys()` 方法会返回一个由一个**给定对象**的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用 [\`for...in` 循环遍历该对象时返回的顺序一致 。
- **给定对象** 并非表示必须是Object类型，Array也可以使用此方法
- 如果给定对象是Object，返回的就是这个对象所有可枚举属性的key(键)所组成的数组；如果给定对象是一个Array，返回的就是这个数组元素索引(索引会被转成字符串)所组成的数组
- 语法：`Object.keys(obj)`
  - `obj` 要返回其枚举自身属性的对象。
  - 返回值 一个表示给定对象的所有可枚举属性的字符串数组

```js
const obj = {name: '李白', sexCode: 1, height: 170};
const arr = ['李白', ['height',170], ['sexCode', 1]];
const str = 'hello world';

const objKeys = Object.keys(obj); // 输出 ["name", "sexCode", "height"]
const arrKeys = Object.keys(arr); // 输出 ["0", "1", "2"]
const strKeys = Object.keys(str); // 输出 ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10"]

// 拿到key值组成的数组后，就可以换种方式去遍历对象（虽然for...of...非常香）
objKeys.forEach(key => {
  console.log(obj[key])
});
```

## values

- 此API是ES8新加的，IE不支持
- `Object.values()`方法返回一个给定对象自身的所有可枚举属性值的数组，值的顺序与使用`for...in`循环的顺序相同 ( 区别在于 for-in 循环枚举原型链中的属性 )
- `Object.values()` 和`Object.keys()` 是相对的，`keys()` 返回键组成的数组，`value()` 返回值组成的数组
- 语法：`Object.values(obj)`
  - `obj` 被返回可枚举属性值的对象。
  - 返回值 一个包含对象自身的所有可枚举属性值的数组。

```js
const obj = {name: '李白', sexCode: 1, height: 170};
const arr = ['李白', ['height',170], ['sexCode', 1]];
const str = 'hello world';

const objValues = Object.values(obj); // 输出 ["李白", 1, 170]
const arrValues = Object.values(arr); // 输出 ["李白", ["height", 170], ["sexCode", 1]]
const strValues = Object.values(str); // 输出 ["h", "e", "l", "l", "o", " ", "w", "o", "r", "l", "d"]

// 结合数组的 every() 和 some() 来做数据校验
const res = objValues.some(item => item === '李白');
```

## entries



## 属性简洁表示法

## 属性名表达式

## 其他（不常用）

### super

### fromEntries

### freeze

### isFrozen
