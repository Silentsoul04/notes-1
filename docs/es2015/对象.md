---
title: 对象
---

## is

* 此API为ES6新增API
* `Object.is()` 方法判断两个值是否是[相同的值](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Equality_comparisons_and_sameness)。
* 在ES6之前判断两个值是否相等只有`==`和`===`,现在我们多了个选择可以使用`Object.is()`
* 语法：`Object.is(value1, value2);`
  * `value1` 第一个需要比较的值
  * `value2` 第二个需要比较的值
  * 返回值 表示比较结果的布尔值

```js
const obj1 = {name: '张三'};
console.log(Object.is(obj1, {name: '张三'})); // false
console.log(obj1 === {name: '张三'}); // false
console.log(obj1 == {name: '张三'}); // false

console.log(Object.is(obj1, obj1)); // true
console.log(obj1 === obj1); // true
console.log(obj1 == obj1); // true

const num1 = +0;
console.log(Object.is(num1, -0)); // false
console.log(num1 === -0); // true
console.log(num1 == -0); // true
```

> 补充：js对于引用类型的比较实质是内存地址的比较，而不是内容的比较；对于原始类型的比较是值得比较
>
> 其实`Object.is()` 基本和`===` 是一样的，不同的地方就是：一是`+0`不等于`-0`（在`===`中 `+0 === -0`是true），二是`NaN`等于自身（在`===`中 `NaN === NaN`是false）
>
>  `==` 的比较会先进行类型转换再进行比较，而`===` 不会。这两区别在最开始学习js的时候应该是有进行了解的 

## assign

* 此API是ES6新增的API
* `assign()` 用于将一个或多个对象的可枚举属性拷贝到目标对象，并返回目标对象
* `assign()` 简单讲就是多个对象合并，但如果目标对象（要合入的对象）和来源对象（拷贝来源对象的属性粘贴到目标对象）有相同的key，则来源对象的key会覆盖目标对象的key，来源对象后面还有若干个来源对象，则后面的会覆盖前面的。
* 该操作会修改目标对象
*  `Object.assign()`拷贝的是属性值。假如源对象的属性值是一个对象的引用，那么它也只指向那个引用
* 语法：`Object.assign(target, ...sources)`
  - `target` 目标对象
  - `sources` 源对象
  - 返回值 目标对象

```js
const target = {name: '李白', id: 1098};
const sources1 = {sexCode: 1, age: 99, id: 1010};
const sources2 = {name: '杜甫', id: 1209, height: 170};

const result = Object.assign(target,sources1,sources2);
console.log(result); // { name: "杜甫", id: 1209, sexCode: 1, age: 99, height: 170 } 源对象与目标对象相同的key 后者会覆盖前者
console.log(target); // { name: "杜甫", id: 1209, sexCode: 1, age: 99, height: 170 } assign 会修改目标对象
console.log(sources1); // { sexCode: 1, age: 99, id: 1010 }
console.log(sources2); // { name: "杜甫", id: 1209, height: 170 }
```

```js
const sources1 = {sexCode: 1, age: 99, id: 1010};
const sources2 = {name: '杜甫', id: 1209, height: 170};
const sources3 = {sources: sources2};
const result2 = Object.assign(sources1,sources2,sources3);
console.log(result2);
// 输出 { sexCode: 1, age: 99, id: 1209, name: "杜甫", height: 170, sources: Object { name: "杜甫", id: 1209, height: 170 } }
sources2.weight = '68kg';
console.log(result2);
// 输出 { sexCode: 1, age: 99, id: 1209, name: "杜甫", height: 170, sources: Object { name: "杜甫", id: 1209, height: 170, weight: "68kg" } }
console.log(sources2);
// 输出 { name: "杜甫", id: 1209, height: 170, weight: "68kg" }
console.log(sources3);
// 输出 { sources: Object { name: "杜甫", id: 1209, height: 170, weight: "68kg" } }
```

> `sources3` 对象的`sources` 属性是引用的`sources2` 对象，所以`sources2` 对象被修改，`sources3` 的`sources` 的值就会同步被修改。
>
> `sources1` 对象将`sources3` 对象的`sources` 属性拷贝进去了，`sources3` 对象的`sources` 引用的是`sources2` 对象，**所以** ，最终也就是`sources1`对象`sources` 也引用了`sources2` 对象，所以`sources2` 修改的同时，所有引用了它的（对象），都会被修改

```js
const sources = {sexCode: 1, id: 1010};
Object.defineProperty(sources, 'age', {
  enumerable: false,
  value: 99,
});
console.log(sources); // 输出 {sexCode: 1, id: 1010, age: 99}
const result = Object.assign({},sources);
console.log(result); // 输出 {sexCode: 1, id: 1010}
```

> `sources` 是源对象，我们给其设置了一个`age` 的不可枚举属性，使用`assign()` API 将其合并入一个空数组，由于`age` 属性是不可枚举的，所以`age` 并没有被`assign()`进行拷贝

## keys

## values

## entries

## 属性简洁表示法

## 属性名表达式

## 其他（不常用）

### super

### fromEntries

### freeze

### isFrozen
