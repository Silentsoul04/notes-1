---
title: 对象
---

## is

* 此API为ES6新增API
* `Object.is()` 方法判断两个值是否是[相同的值](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Equality_comparisons_and_sameness)。
* 在ES6之前判断两个值是否相等只有`==`和`===`,现在我们多了个选择可以使用`Object.is()`
* 语法：`Object.is(value1, value2);`
  * `value1` 第一个需要比较的值
  * `value2` 第二个需要比较的值
  * 返回值 表示比较结果的布尔值

```js
const obj1 = {name: '张三'};
console.log(Object.is(obj1, {name: '张三'})); // false
console.log(obj1 === {name: '张三'}); // false
console.log(obj1 == {name: '张三'}); // false

console.log(Object.is(obj1, obj1)); // true
console.log(obj1 === obj1); // true
console.log(obj1 == obj1); // true

const num1 = +0;
console.log(Object.is(num1, -0)); // false
console.log(num1 === -0); // true
console.log(num1 == -0); // true
```

> 补充：js对于引用类型的比较实质是内存地址的比较，而不是内容的比较；对于原始类型的比较是值得比较
>
> 其实`Object.is()` 基本和`===` 是一样的，不同的地方就是：一是`+0`不等于`-0`（在`===`中 `+0 === -0`是true），二是`NaN`等于自身（在`===`中 `NaN === NaN`是false）
>
>  `==` 的比较会先进行类型转换再进行比较，而`===` 不会。这两区别在最开始学习js的时候应该是有进行了解的 

## assign

* `assign`

## keys

## values

## entries

## 属性简洁表示法

## 属性名表达式

## 其他（不常用）

### super

### fromEntries

### freeze

### isFrozen
