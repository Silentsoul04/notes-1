<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>胖大人的日常记事</title>
    <meta name="description" content="Just playing around">
    <link rel="icon" href="logo.png">
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#3eaf7c">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <link rel="apple-touch-icon" href="logo.png">
  <link rel="mask-icon" href="logo.svg" color="#3eaf7c">
  <meta name="msapplication-TileImage" content="logo_144*144.png">
  <meta name="msapplication-TileColor" content="#000000">
    
    <link rel="preload" href="/assets/css/0.styles.be15e0e1.css" as="style"><link rel="preload" href="/assets/js/app.745025a3.js" as="script"><link rel="preload" href="/assets/js/2.d6c01b35.js" as="script"><link rel="preload" href="/assets/js/31.48156b6a.js" as="script"><link rel="prefetch" href="/assets/js/10.b15f60e2.js"><link rel="prefetch" href="/assets/js/11.535b2ad8.js"><link rel="prefetch" href="/assets/js/12.46ffc8b5.js"><link rel="prefetch" href="/assets/js/13.4b23805e.js"><link rel="prefetch" href="/assets/js/14.6e6cf41b.js"><link rel="prefetch" href="/assets/js/15.47414791.js"><link rel="prefetch" href="/assets/js/16.ecc1171d.js"><link rel="prefetch" href="/assets/js/17.c118399e.js"><link rel="prefetch" href="/assets/js/18.eea3e35b.js"><link rel="prefetch" href="/assets/js/19.b12d698f.js"><link rel="prefetch" href="/assets/js/20.a584b4e7.js"><link rel="prefetch" href="/assets/js/21.3e0bdf10.js"><link rel="prefetch" href="/assets/js/22.276850a1.js"><link rel="prefetch" href="/assets/js/23.b3efca3c.js"><link rel="prefetch" href="/assets/js/24.c7601923.js"><link rel="prefetch" href="/assets/js/25.39614ac1.js"><link rel="prefetch" href="/assets/js/26.60483ab2.js"><link rel="prefetch" href="/assets/js/27.bfb61d9d.js"><link rel="prefetch" href="/assets/js/28.7dadd6bc.js"><link rel="prefetch" href="/assets/js/29.59b2df76.js"><link rel="prefetch" href="/assets/js/3.ded4051d.js"><link rel="prefetch" href="/assets/js/30.a7a4f806.js"><link rel="prefetch" href="/assets/js/32.e7ff8ffb.js"><link rel="prefetch" href="/assets/js/33.d17510e5.js"><link rel="prefetch" href="/assets/js/34.f00dca94.js"><link rel="prefetch" href="/assets/js/35.303cbcea.js"><link rel="prefetch" href="/assets/js/36.e8a1ac2f.js"><link rel="prefetch" href="/assets/js/37.e187a446.js"><link rel="prefetch" href="/assets/js/38.75296055.js"><link rel="prefetch" href="/assets/js/39.81ede555.js"><link rel="prefetch" href="/assets/js/4.eef6d0a5.js"><link rel="prefetch" href="/assets/js/40.92086d8f.js"><link rel="prefetch" href="/assets/js/41.77fe8ac2.js"><link rel="prefetch" href="/assets/js/42.ad77dce1.js"><link rel="prefetch" href="/assets/js/43.714ecbf7.js"><link rel="prefetch" href="/assets/js/44.bb453227.js"><link rel="prefetch" href="/assets/js/45.7bd9bdc7.js"><link rel="prefetch" href="/assets/js/5.ae17a9ef.js"><link rel="prefetch" href="/assets/js/6.41716a03.js"><link rel="prefetch" href="/assets/js/7.137caa55.js"><link rel="prefetch" href="/assets/js/8.f552d2b6.js"><link rel="prefetch" href="/assets/js/9.e9d1275f.js">
    <link rel="stylesheet" href="/assets/css/0.styles.be15e0e1.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">胖大人的日常记事</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">Home</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">Home</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/0001.html" class="sidebar-link">01 开篇词 | 使用 Webpack 实现前端工程化</a></li><li><a href="/0002.html" class="sidebar-link">02 什么是 Webpack</a></li><li><a href="/0003.html" class="sidebar-link">03 Webpack 开发环境搭建</a></li><li><a href="/0004.html" class="sidebar-link">04 使用 webpack-cli 体验零配置打包</a></li><li><a href="/0005.html" class="sidebar-link">05 基础概念和常见配置项介绍（一）</a></li><li><a href="/0006.html" class="sidebar-link">06 基础概念和常见配置项介绍（二）</a></li><li><a href="/0007.html" class="sidebar-link">07 Webpack 中的模块化开发</a></li><li><a href="/0008.html" class="sidebar-link">08 在 Webpack 中使用 Babel 转换 JavaScript 代码</a></li><li><a href="/0009.html" class="sidebar-link">09 Webpack 中使用 TypeScript 开发项目</a></li><li><a href="/0010.html" class="sidebar-link">10 Webpack 中样式相关的配置</a></li><li><a href="/0011.html" class="sidebar-link">11 Webpack 中使用 lint 工具来保证代码风格和质量</a></li><li><a href="/0012.html" class="sidebar-link">12 使用 Webpack 管理项目中的静态资源</a></li><li><a href="/0013.html" class="sidebar-link">13 Webpack 中打包 HTML 和多页面配置</a></li><li><a href="/0014.html" class="sidebar-link">14 Webpack Dev Server 本地开发服务</a></li><li><a href="/0015.html" class="sidebar-link">15 Webpack 中配置React和Vue开发环境</a></li><li><a href="/0016.html" class="sidebar-link">16 Webpack 环境相关配置及配置文件拆分</a></li><li><a href="/0017.html" class="sidebar-link">17 Webpack 优化之体积优化</a></li><li><a href="/0018.html" class="sidebar-link">18 Webpack 优化之增强缓存命中率</a></li><li><a href="/0019.html" class="sidebar-link">19 使用 Webpack 的 splitChunks 功能来拆分代码</a></li><li><a href="/0020.html" class="sidebar-link">20 Webpack 优化之速度优化</a></li><li><a href="/0021.html" class="sidebar-link">21 使用 Webpack 的 Tree-Shaking</a></li><li><a href="/0022.html" class="sidebar-link">22 为你准备了一份 Webpack 工程化最佳实践总结</a></li><li><a href="/0023.html" class="sidebar-link">23 怎么调试 Webpack？</a></li><li><a href="/0024.html" class="sidebar-link">24 Tapable —— Webpack 的核心模块</a></li><li><a href="/0025.html" class="sidebar-link">25 Webpack 的 Compiler 和 Compilation</a></li><li><a href="/0026.html" class="active sidebar-link">26 Webpack 工作流程</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/0026.html#基本流程" class="sidebar-link">基本流程</a></li><li class="sidebar-sub-header"><a href="/0026.html#compiler" class="sidebar-link">Compiler</a></li><li class="sidebar-sub-header"><a href="/0026.html#compilation" class="sidebar-link">Compilation</a></li><li class="sidebar-sub-header"><a href="/0026.html#compiler-和-compilation-关系" class="sidebar-link">Compiler 和 Compilation 关系</a></li><li class="sidebar-sub-header"><a href="/0026.html#webpack-流程源码解析" class="sidebar-link">Webpack 流程源码解析</a></li><li class="sidebar-sub-header"><a href="/0026.html#验证全流程" class="sidebar-link">验证全流程</a></li><li class="sidebar-sub-header"><a href="/0026.html#全流程图" class="sidebar-link">全流程图</a></li><li class="sidebar-sub-header"><a href="/0026.html#总结" class="sidebar-link">总结</a></li></ul></li><li><a href="/0027.html" class="sidebar-link">27 从 Webpack 的产出代码来看 Webpack 是怎么执行的</a></li><li><a href="/0028.html" class="sidebar-link">28 Webpack 的模块热替换做了什么？</a></li><li><a href="/0029.html" class="sidebar-link">29 实战：使用 PostCSS 打造移动适配方案</a></li><li><a href="/0030.html" class="sidebar-link">30 实战：手写一个 markdown-loader</a></li><li><a href="/0031.html" class="sidebar-link">31 实战：手写一个 prefetch-webpack-plugin 插件</a></li><li><a href="/0032.html" class="sidebar-link">32 实战：使用 Express 和中间件来实现 Webpack-dev-server</a></li><li><a href="/0033.html" class="sidebar-link">33 实战：使用 Stats 数据结构生成 Webpack 构建报告</a></li><li><a href="/0034.html" class="sidebar-link">34 实战：给 Webpack 项目添加 modern</a></li><li><a href="/0035.html" class="sidebar-link">35 Webpack 5.0</a></li><li><a href="/0036.html" class="sidebar-link">36 课程总结</a></li><li><a href="/0037.html" class="sidebar-link">37 附录：项目中常用的 loader</a></li><li><a href="/0038.html" class="sidebar-link">38 附录：项目中常用的插件</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p><img src="https://img3.mukewang.com/5cd964700001973406390359.jpg" alt=""></p> <blockquote><p>机会不会上门来找人，只有人去找机会。</p> <p>               ——狄更斯</p></blockquote> <p>Webpack 主要工作是从一个入口开始，将小块独立的代码编制成更大而复杂的可以运行在浏览器中的代码，独立的代码就是一些 JavaScript 及其它可以被 JavaScript 引用的文件。今天章节来理解下 Webpack 的工作流程和基本原理。为了方便理解，我先将 Webpack 整个工作流程打个比方：</p> <p>Webpack 可以看做是一个工厂车间，<code>plugin</code>和<code>loader</code>是车间中的两类机器，工厂有一个车间主任和一个生产车间。车间主任叫<code>Compiler</code>，负责指挥生产车间机器<code>Compilation</code>进行生产劳动，<code>Compilation</code>会首先将进来的原材料（<code>entry</code>）使用一种叫做<code>loader</code>的机器进行加工，生产出来的产品就是<code>Chunk</code>；<code>Chunk</code>生产出来之后，会被组装成<code>Bundle</code>，然后通过一类<code>plugin</code>的机器继续加工，得到最后的<code>Bundle</code>，然后运输到对应的仓库（<code>output</code>）。这个工厂的生产线就是 <strong>Tapable</strong>，厂子运作的整个流程都是生产线控制的，车间中有好几条生产线，每个生产线有很多的操作步骤（<code>hook</code>），一步操作完毕，会进入到下一步操作，直到生产线全流程完成，再将产出传给下一个产品线处理。整个车间生产线也组成了一条最大的生产线。</p> <p>上面的例子揭示了整个 Webpack 工作流程，其中我们可以看到我们配置的<code>webpack.config.js</code>当中的<code>entry</code>和<code>output</code>，也可以看到我们配置的<code>loader</code>。</p> <blockquote><p><em><strong>Tips：</strong></em> 为了更好的理解 Webpack 的工作原理，推荐阅读下minipack这个项目，中文版本的在这里。</p></blockquote> <h2 id="基本流程"><a href="#基本流程" aria-hidden="true" class="header-anchor">#</a> 基本流程</h2> <p>Webpack 的基本流程可以分为三个阶段：</p> <ol><li>准备阶段：主要任务是创建 Compiler 和 Compilation 对象；</li> <li>编译阶段：这个阶段任务是完成 modules 解析，并且生成 chunks；
<ul><li>module 解析：包含了三个主要步骤，创建实例、loaders 应用和依赖收集；</li> <li>chunks 生成，主要步骤是找到每个 chunk 所需要包含的 modules。</li></ul></li> <li>产出阶段：这个阶段的主要任务是根据 chunks 生成最终文件，主要有三个步骤：模板 Hash 更新，模板渲染 chunk，生成文件。</li></ol> <p>细化到具体的代码层次，大概可以分为：</p> <ol><li>初始化参数：包括从配置文件和 shell 中读取和合并参数，然后得出最终参数；shell 中的参数要优于配置文件的；</li> <li>使用上一步得到的参数实例化一个 Compiler 类，注册所有的插件，给对应的 Webpack 构建生命周期绑定 Hook；</li> <li>开始编译：执行 Compiler 类的 run 方法开始执行编译；</li></ol> <p><code>compiler.run</code> 方法调用 <code>compiler.compile</code>，在compile 内实例化一个Compilation类，Compilation是做构建打包的事情，主要事情包括：</p> <p>1）查找入口：根据 entry 配置，找出全部的入口文件；
2）编译模块：根据文件类型和 loader 配置，使用对应 loader 对文件进行转换处理；
3）解析文件的 AST 语法树；
4）找出文件依赖关系；
5）递归编译依赖的模块。</p> <p>递归完后得到每个文件的最终结果，根据 <code>entry</code> 配置生成代码块 <code>chunk</code>；
输出所有 chunk 到对应的<code>output</code>路径。</p> <blockquote><p><em><strong>Tips:</strong></em> shell 中的参数要优于配置文件。举例说明：配置文件指定了 <code>mode</code> 是<code>development</code>，而 <code>shell</code> 中传入了<code>--mode production</code>，则最终 <code>mode</code> 值为<code>production</code>。</p></blockquote> <p>在 Webpack 工作流程里，<code>Tapable</code>始终贯穿其中，<code>Tapable</code> 各种 <code>Hook</code>（钩子）组成了 <code>Webpack</code> 的生命周期。<code>Tapable Hook</code> 和生命周期的关系为：</p> <p><strong>Hook：</strong> 钩子，对应 Tapable 的 Hook；
<strong>生命周期：</strong> Webpack 的执行流程，钩子实际就是生命周期，一般类似 <code>entryOption</code> 的 <code>Hook</code>，在生命周期中<code>entry-option</code>。</p> <p>参与 Webpack 流程的两个重要模块是：<code>Compiler</code>和<code>Compilation</code>。关于<code>Compiler</code>和<code>Compilation</code>这里先简单做下介绍，本文主要讲解 Webpack 的工作流程，它俩在后续章节会继续详细解释。</p> <h2 id="compiler"><a href="#compiler" aria-hidden="true" class="header-anchor">#</a> Compiler</h2> <p><code>Compiler</code> 继承自 <code>Tapable</code>，是 Webpack 的整个生命周期管理，代表了完整的 Webpack 环境配置。每个 Webpack 的配置，对应一个Compiler对象，记录了 Webpack 的 <code>options</code>、<code>loader</code> 和 <code>plugin</code>等信息，并且通过Tapable的 Hook 机制管理整个打包流程的生命周期。</p> <h2 id="compilation"><a href="#compilation" aria-hidden="true" class="header-anchor">#</a> Compilation</h2> <p><code>Compilation</code> 也继承自 <code>Tapable</code>，代表了一次资源版本构建，包含了当前的模块资源、编译生成资源、变化的文件、以及被跟踪依赖的状态信息。每次构建过程都会产生一次Compilation，比如我们启动 <strong>watch</strong> 功能的时候，每当检测到一个文件变化，就会重新创建一个新的 Compilation，从而生成一组新的编译资源。</p> <blockquote><p>*<strong>Tips：</strong> Webpack 的插件是在apply方法接收Compiler对象来给某个流程添加钩子回调，钩子回调函数接收的是记录当前状态的Compilation对象，后面 plugin 小节内容继续做介绍。</p></blockquote> <h2 id="compiler-和-compilation-关系"><a href="#compiler-和-compilation-关系" aria-hidden="true" class="header-anchor">#</a> Compiler 和 Compilation 关系</h2> <p><strong>Compiler：</strong> 代表的是不变的 Webpack 环境，是针对 Webpack 的。例如 watch 模式下，传入的 Webpack 配置是不变的，不管执行几次 Compilation 都不变；
<strong>Compilation：</strong> 针对的是随时可变的项目文件，只要文件有改动，Compilation 就会被重新创建。</p> <h2 id="webpack-流程源码解析"><a href="#webpack-流程源码解析" aria-hidden="true" class="header-anchor">#</a> Webpack 流程源码解析</h2> <h4 id="准备阶段"><a href="#准备阶段" aria-hidden="true" class="header-anchor">#</a> 准备阶段</h4> <p>当我们开始运行 Webpack 的时候，就会创建 Compiler 实例并且加载内置插件。这里跟构建流程相关性比较大的内置插件是EntryOptionPlugin，它会解析传给 Webpack 的配置中的 entry。这里不同类型的 entry包括：<code>SingleEntryPlugin</code>、<code>MultiEntryPlugin</code>、<code>DynamicEntryPlugin</code>三类，分别对应着单文件入口、多文件入口和动态文件入口（忘记的翻下 Webpack 基础概念里面 entry 部分的内容），对应代码如下：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// webpack 4.29.6</span>
<span class="token comment">// lib/EntryOptionPlugin.js</span>
<span class="token keyword">const</span> <span class="token function-variable function">itemToPlugin</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">context<span class="token punctuation">,</span> item<span class="token punctuation">,</span> name</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MultiEntryPlugin</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> item<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SingleEntryPlugin</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> item<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token keyword">class</span> <span class="token class-name">EntryOptionPlugin</span> <span class="token punctuation">{</span>
    <span class="token function">apply</span><span class="token punctuation">(</span><span class="token parameter">compiler</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        compiler<span class="token punctuation">.</span>hooks<span class="token punctuation">.</span>entryOption<span class="token punctuation">.</span><span class="token function">tap</span><span class="token punctuation">(</span><span class="token string">'EntryOptionPlugin'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">context<span class="token punctuation">,</span> entry</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token comment">// 看这里，判断webpack.config中entry的类型判断，然后选择对应的Entry</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> entry <span class="token operator">===</span> <span class="token string">'string'</span> <span class="token operator">||</span> Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>entry<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">itemToPlugin</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> entry<span class="token punctuation">,</span> <span class="token string">'main'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>compiler<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> entry <span class="token operator">===</span> <span class="token string">'object'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> name <span class="token keyword">of</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>entry<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token function">itemToPlugin</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> entry<span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>compiler<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> entry <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">new</span> <span class="token class-name">DynamicEntryPlugin</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> entry<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>compiler<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>除了 <code>EntryOptionPlugin</code>，其他的内置插件也会监听特定的任务点来完成特定的逻辑，但我们这里不再仔细讨论。当 <code>Compiler</code> 实例加载完内置插件之后，下一步就会直接调用 <code>compiler.run</code> 方法来启动构建，这时候 <code>Compiler</code> 的run 钩子被触发，在run钩子回调中可以得到解析后的<code>compiler.options</code>。</p> <blockquote><p><em><strong>Tips：</strong></em> <code>run</code>钩子只有在 Webpack 以正常模式运行的情况下会触发，如果我们以监听 （<code>watch</code>）模式运行 Webpack，那么<code>run</code>是不会触发的，但是会触发<code>watchRun</code>钩子。</p></blockquote> <p>完成了 Webpack 配置的处理，接下来开始构建流程，构建流程主要是在<code>Compiler</code>的<code>Compiler.compile</code>内：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// webpack v4.29.6</span>
<span class="token comment">// lib/Compiler.js#L610-L636</span>
<span class="token function">compile</span><span class="token punctuation">(</span><span class="token parameter">callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Compilation类的参数</span>
    <span class="token keyword">const</span> params <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">newCompilationParams</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 1. 执行beforeCompile 钩子回调</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>hooks<span class="token punctuation">.</span>beforeCompile<span class="token punctuation">.</span><span class="token function">callAsync</span><span class="token punctuation">(</span>params<span class="token punctuation">,</span> <span class="token parameter">err</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">callback</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 2. 执行 Compiler.compile 钩子回调</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>hooks<span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 3. 实例化 Compilation</span>
        <span class="token keyword">const</span> compilation <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">newCompilation</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 4. 执行 Compiler.make 钩子回调</span>
        <span class="token comment">// make内实际主要是执行的compilation的addEntry方法(**注意这里**)</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>hooks<span class="token punctuation">.</span>make<span class="token punctuation">.</span><span class="token function">callAsync</span><span class="token punctuation">(</span>compilation<span class="token punctuation">,</span> <span class="token parameter">err</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">callback</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>

            compilation<span class="token punctuation">.</span><span class="token function">finish</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// seal方法整理构建之后的chunk产出</span>
            <span class="token comment">// 这里会做一些优化相关的事情，比如压缩代码等</span>
            compilation<span class="token punctuation">.</span><span class="token function">seal</span><span class="token punctuation">(</span><span class="token parameter">err</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">callback</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 执行 Compiler.afterCompile 钩子回调</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>hooks<span class="token punctuation">.</span>afterCompile<span class="token punctuation">.</span><span class="token function">callAsync</span><span class="token punctuation">(</span>compilation<span class="token punctuation">,</span> <span class="token parameter">err</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">callback</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>

                    <span class="token keyword">return</span> <span class="token function">callback</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> compilation<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>newCompilationParams</code>主要是生成对应 compilation 用到的参数：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// webpack 4.29.6</span>
<span class="token comment">// lib/Compiler.js#L601</span>
<span class="token function">newCompilationParams</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> params <span class="token operator">=</span> <span class="token punctuation">{</span>
        <span class="token comment">// normal module</span>
        normalModuleFactory<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">createNormalModuleFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token comment">// context module</span>
        contextModuleFactory<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">createContextModuleFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token comment">// 依赖关系表</span>
        compilationDependencies<span class="token punctuation">:</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> params<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>紧接着 <code>Compiler</code> 实例开始创建 <code>Compilation</code> 对象，这个对象是后续构建流程中最核心最重要的对象，它包含了一次构建过程中所有的数据，一次构建过程对应一个 <code>Compilation</code> 实例。当 Compilation 实例创建完成之后，Webpack 的准备阶段已经完成，下一步将开始编译阶段。</p> <h4 id="编译阶段"><a href="#编译阶段" aria-hidden="true" class="header-anchor">#</a> 编译阶段</h4> <p>从 <strong><code>Compiler</code> 的make钩子触发开始</strong>，此时内置插件<code>SingleEntryPlugin</code>、<code>MultiEntryPlugin</code>、<code>DynamicEntryPlugin</code>（根据不同类型 <code>entry</code>）的监听器会开始执行。监听器都会调用 <code>Compilation</code> 实例的 <code>compilation.addEntry()</code> 方法，该方法将会触发第一批 <code>module</code> 的解析，这些 <code>module</code> 就是 <code>entry</code> 中配置的模块。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// webpack 4.29.6</span>
<span class="token comment">// lib/Compilation.js#L1019</span>
<span class="token function">addEntry</span><span class="token punctuation">(</span><span class="token parameter">context<span class="token punctuation">,</span> entry<span class="token punctuation">,</span> name<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
    <span class="token comment">// 执行内部_addModuleChain方法</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_addModuleChain</span><span class="token punctuation">(</span>
        context<span class="token punctuation">,</span>
        entry<span class="token punctuation">,</span>
        <span class="token parameter">module</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>entries<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>module<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span> module</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token comment">// ...</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们先讲一个 module 解析完成之后的操作，它会递归调用它所依赖的 modules 进行解析，所以当解析停止时，我们就能够得到项目中所有依赖的 modules，它们将存储在 Compilation 实例的 modules 属性中，并触发<code>compilation</code>的<code>finishModules</code>钩子。</p> <p>module对象有 <code>NormalModule</code>、 <code>MultiModule</code>、<code>ContextModule</code>、<code>DLLModule</code>等多种类型（分别在对应的<code>lib/*Module.js</code>中实现）。下面以<code>NormalModule</code>为例讲解下 module 的解析流程，其他类型的解析都是类似。</p> <p><strong>NormalModule</strong> 的实例化需要借用对应的<code>NormalModuleFactory.create()</code>，NormalModuleFactory则来自于上一阶段创建Compilation对象传入的参数。创建NormalModule之前会调用resolver来获取一个 module 的属性，比如解析这个 module 需要用到的 loaders，资源路径resource 等等。</p> <p><strong>Resolver</strong> 是指来自于<code>enhanced-resolve</code>模块，它主要功能是一个提供异步<code>require.resolve()</code>，即从哪里去查找文件的路径，可以通过 Webpack 的resolve和resolveLoader来配置。Compiler 类有三种类型的内置 Resolver：</p> <ul><li>Normal：通过绝对路径或相对路径，解析一个模块；</li> <li>Context：通过给定的上下文（context）解析一个模块；</li> <li>Loader：解析一个 webpack loader。</li></ul> <p>在创建完 <code>NormalModule</code> 实例之后会调用 <code>NormalModule.build()</code> 方法继续进行内部的构建，NormalModule.build()会调用NormalModule.doBuild()，在doBuild()中执行 loader，生成 AST 语法树。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// webpack 4.29.6</span>
<span class="token comment">// lib/NormalModule.js#L274</span>
<span class="token function">doBuild</span><span class="token punctuation">(</span><span class="token parameter">options<span class="token punctuation">,</span> compilation<span class="token punctuation">,</span> resolver<span class="token punctuation">,</span> fs<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 生成loader上下文</span>
    <span class="token keyword">const</span> loaderContext <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">createLoaderContext</span><span class="token punctuation">(</span>
        resolver<span class="token punctuation">,</span>
        options<span class="token punctuation">,</span>
        compilation<span class="token punctuation">,</span>
        fs
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 开始执行loader</span>
    <span class="token function">runLoaders</span><span class="token punctuation">(</span>
        <span class="token punctuation">{</span>
            resource<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>resource<span class="token punctuation">,</span>
            loaders<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>loaders<span class="token punctuation">,</span>
            context<span class="token punctuation">:</span> loaderContext<span class="token punctuation">,</span>
            readResource<span class="token punctuation">:</span> fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>fs<span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span> result</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token comment">// ...</span>

            <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// ...</span>
                <span class="token keyword">return</span> <span class="token function">callback</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

            <span class="token keyword">const</span> resourceBuffer <span class="token operator">=</span> result<span class="token punctuation">.</span>resourceBuffer<span class="token punctuation">;</span>
            <span class="token keyword">const</span> source <span class="token operator">=</span> result<span class="token punctuation">.</span>result<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">const</span> sourceMap <span class="token operator">=</span> result<span class="token punctuation">.</span>result<span class="token punctuation">.</span>length <span class="token operator">&gt;=</span> <span class="token number">1</span> <span class="token operator">?</span> result<span class="token punctuation">.</span>result<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
            <span class="token keyword">const</span> extraInfo <span class="token operator">=</span> result<span class="token punctuation">.</span>result<span class="token punctuation">.</span>length <span class="token operator">&gt;=</span> <span class="token number">2</span> <span class="token operator">?</span> result<span class="token punctuation">.</span>result<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

            <span class="token comment">// ...</span>
            <span class="token comment">// 这里是处理后的源码</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>_source <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">createSource</span><span class="token punctuation">(</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>binary <span class="token operator">?</span> <span class="token function">asBuffer</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token function">asString</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span><span class="token punctuation">,</span>
                resourceBuffer<span class="token punctuation">,</span>
                sourceMap
            <span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 这里是ast</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>_ast <span class="token operator">=</span>
                <span class="token keyword">typeof</span> extraInfo <span class="token operator">===</span> <span class="token string">&quot;object&quot;</span> <span class="token operator">&amp;&amp;</span>
                extraInfo <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span>
                extraInfo<span class="token punctuation">.</span>webpackAST <span class="token operator">!==</span> <span class="token keyword">undefined</span>
                    <span class="token operator">?</span> extraInfo<span class="token punctuation">.</span>webpackAST
                    <span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>当一个模块编译完成之后，有会根据其AST查找依赖，递归整个构建流程，直到整个所有依赖都被处理完毕。得到所有的 modules 之后，Webpack 会开始生成对应的 chunk。这些 chunk 对象是 Webpack 生成最终文件的一个重要依据。每个 chunk 的生成就是找到需要包含的 modules。这里大致描述一下 chunk 的生成算法：</p> <ol><li>Webpack 先将 entry 中对应的 module 都生成一个新的 chunk；</li> <li>遍历 module 的依赖列表，将依赖的 module 也加入到 chunk 中；</li> <li>如果一个依赖 module 是动态引入（import()、require.ensure()）的模块，那么就会根据这个 module 创建一个新的 chunk，继续遍历依赖；</li> <li>重复上面的过程，直至得到所有的 chunks。</li> <li>得到所有 chunks 之后，Webpack 会对 chunks 和 modules 进行一些优化相关的操作，比如分配 id、排序等，即进入到compilation.seal()内，这时候会触发webpack.optimize配置中用到的一些插件。</li></ol> <p>至此，编译阶段处理完成，进入产出阶段。</p> <h4 id="产出阶段"><a href="#产出阶段" aria-hidden="true" class="header-anchor">#</a> 产出阶段</h4> <p>在产出阶段，webpack 会根据 chunks 生成最终文件。主要有三个步骤：模板 hash 更新，模板渲染 chunk，生成 bunlde 文件。</p> <p><strong>Compilation</strong> 在实例化的时候，就会同时实例化三个对象： <code>MainTemplate</code>，<code>ChunkTemplate</code>，<code>ModuleTemplate</code>，这三个对象是用来渲染 chunk 对象，得到最终代码的模板。</p> <ul><li>MainTemplate：对应了在 entry 配置的入口 chunk 的渲染模板；</li> <li>ChunkTemplate：动态引入的非入口 chunk 的渲染模板；</li> <li>ModuleTemplate：chunk 中的 module 的渲染模板。</li></ul> <p>在开始渲染之前， <strong>Compilation</strong> 实例会调用 <code>compilation.createHash</code> 方法来生成这次构建的 <strong>Hash</strong>，在 Webpack 的配置中，我们可以在 <code>output.filename</code> 中配置 <code>[hash]</code> 占位符，最终就会替换成这个 Hash。同样， <code>compilation.createHash</code> 也会为每一个 chunk 也创建一个 Hash，对应 <code>[chunkhash]</code> 占位符。</p> <p>当 <strong>Hash</strong> 都创建完成之后，下一步就会遍历 compilation对象的chunks属性，来渲染每一个 chunk。如果一个 chunk 是入口（entry） chunk，那么就会调用 MainTemplate 实例的 render 方法，否则调用 ChunkTemplate 的 render 方法：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// webpack 4.29.6</span>
<span class="token comment">// lib/Compilation.js#L2314</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> chunks<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> chunk <span class="token operator">=</span> chunks<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> chunkHash <span class="token operator">=</span> <span class="token function">createHash</span><span class="token punctuation">(</span>hashFunction<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>outputOptions<span class="token punctuation">.</span>hashSalt<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            chunkHash<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span>outputOptions<span class="token punctuation">.</span>hashSalt<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        chunk<span class="token punctuation">.</span><span class="token function">updateHash</span><span class="token punctuation">(</span>chunkHash<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 根据类型选择模板</span>
        <span class="token keyword">const</span> template <span class="token operator">=</span> chunk<span class="token punctuation">.</span><span class="token function">hasRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainTemplate <span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>chunkTemplate<span class="token punctuation">;</span>
        template<span class="token punctuation">.</span><span class="token function">updateHashForChunk</span><span class="token punctuation">(</span>chunkHash<span class="token punctuation">,</span> chunk<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>moduleTemplates<span class="token punctuation">.</span>javascript<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>dependencyTemplates<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>hooks<span class="token punctuation">.</span><span class="token function">chunkHash</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>chunk<span class="token punctuation">,</span> chunkHash<span class="token punctuation">)</span><span class="token punctuation">;</span>
        chunk<span class="token punctuation">.</span>hash <span class="token operator">=</span> chunkHash<span class="token punctuation">.</span><span class="token function">digest</span><span class="token punctuation">(</span>hashDigest<span class="token punctuation">)</span><span class="token punctuation">;</span>
        hash<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span>chunk<span class="token punctuation">.</span>hash<span class="token punctuation">)</span><span class="token punctuation">;</span>
        chunk<span class="token punctuation">.</span>renderedHash <span class="token operator">=</span> chunk<span class="token punctuation">.</span>hash<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> hashDigestLength<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>hooks<span class="token punctuation">.</span><span class="token function">contentHash</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>chunk<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>errors<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ChunkRenderError</span><span class="token punctuation">(</span>chunk<span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>当每个 <strong>chunk</strong> 的源码生成之后，就会添加在 <strong>Compilation 实例对象的 assets 属性中</strong>。assets 中的对象 key 是最终要生成的文件名称， value 是一个对象，对象需要包含两个方法， <code>source</code> 和 <code>size</code> 分别返回文件内容和文件大小。当所有的 chunk 都渲染完成之后， <strong>assets</strong> 就是最终更要生成的文件列表。</p> <p>完成上面的操作之后， Compilation 实例的 seal 方法结束，进入到 Compiler 实例的 emitAssets 方法。 Compilation 实例的所有工作到此也全部结束，意味着一次构建过程已经结束，接下来 Webpack 会直接遍历 compilation.assets 生成所有文件，然后触发任务点 done，结束构建流程。</p> <h2 id="验证全流程"><a href="#验证全流程" aria-hidden="true" class="header-anchor">#</a> 验证全流程</h2> <p>通过 Tapable 文章的内容得知，我们可以给 Tapable 的实例使用 tap 的方式添加回调函数，再结合 Webpack 的 API 章节内容得知<code>webpack(config)</code>返回的实际是compiler，所以我们可以遍历<code>comipler.hooks</code>，使用hook.tap的方法添加回调函数，将 hookName 打印出来，通过这样的方式，可以把 webpack compiler 部分的流程全部输出出来。代码如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> webpack <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'webpack'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> config <span class="token operator">=</span> <span class="token punctuation">{</span>
    mode<span class="token punctuation">:</span> <span class="token string">'development'</span><span class="token punctuation">,</span>
    devtool<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
    <span class="token comment">// 下面是只有一个entry的情况</span>
    <span class="token comment">// 没有output则默认输出是到dist的main</span>
    entry<span class="token punctuation">:</span> <span class="token string">'./src/app.js'</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> compiler <span class="token operator">=</span> <span class="token function">webpack</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 遍历hooks，添加回调，输出`hookName`</span>
Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>compiler<span class="token punctuation">.</span>hooks<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">hookName</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>compiler<span class="token punctuation">.</span>hooks<span class="token punctuation">[</span>hookName<span class="token punctuation">]</span><span class="token punctuation">.</span>tap<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        compiler<span class="token punctuation">.</span>hooks<span class="token punctuation">[</span>hookName<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">tap</span><span class="token punctuation">(</span><span class="token string">'anyString'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">run -&gt; </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>hookName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 触发webpack的编译流程</span>
compiler<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>得到compiler.run()之后的工作流程：</p> <div class="language- extra-class"><pre class="language-text"><code>run -&gt; beforeRun
run -&gt; run
run -&gt; normalModuleFactory
run -&gt; contextModuleFactory
run -&gt; beforeCompile
run -&gt; compile
run -&gt; thisCompilation
run -&gt; compilation
run -&gt; make
run -&gt; afterCompile
run -&gt; shouldEmit
run -&gt; emit
run -&gt; afterEmit
run -&gt; done
</code></pre></div><p>上面的方式是得到了<code>compiler.run()</code>之后的流程，这个流程缺少了环境变量和参数处理的流程，因为这些事情已经在<code>run()</code>操作之前的<code>webpack()</code>调用期间实例化Compiler就做完了。再进一步，我们直接修改<code>node_modules/webpack/lib/Compiler.js</code>的代码，在<code>Compiler.constructor</code>最后添加代码：</p> <div class="language-js extra-class"><pre class="language-js"><code>Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>hooks<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">hookName</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> hook <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>hooks<span class="token punctuation">[</span>hookName<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>hook<span class="token punctuation">.</span>tap<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        hook<span class="token punctuation">.</span><span class="token function">tap</span><span class="token punctuation">(</span><span class="token string">'anyString'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">compiler -&gt; </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>hookName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这样得到更加完整的执行过程：</p> <div class="language- extra-class"><pre class="language-text"><code>compiler -&gt; environment
compiler -&gt; afterEnvironment
compiler -&gt; entryOption
compiler -&gt; afterPlugins
compiler -&gt; afterResolvers
compiler -&gt; beforeRun
compiler -&gt; run
compiler -&gt; normalModuleFactory
compiler -&gt; contextModuleFactory
compiler -&gt; beforeCompile
compiler -&gt; compile
compiler -&gt; thisCompilation
compiler -&gt; compilation
compiler -&gt; make
compiler -&gt; afterCompile
compiler -&gt; shouldEmit
compiler -&gt; emit
compiler -&gt; afterEmit
compiler -&gt; done
</code></pre></div><p>综上，在<code>compiler.run()</code>之前有一下流程：</p> <p>environment
afterEnvironment
entryOption
afterPlugins
afterResolvers</p> <h2 id="全流程图"><a href="#全流程图" aria-hidden="true" class="header-anchor">#</a> 全流程图</h2> <p>通过上面的解释、源码分析和嵌入式代码验证，我们已经了解了 Webpack 打包的全流程，下面是结合上面的内容，整理的一张 Webpack 工作流程图，供大家进一步学习和巩固本文的内容。</p> <p><img src="http://img.mukewang.com/5d0771640001eb5708160557.jpg" alt=""></p> <blockquote><p>Tips: 我们还可以用同样的方法修改<code>node_modules/webpack/lib/Compilation.js</code> ，也添加上 <strong>hooks</strong> 的遍历，这样可以通过输出的 <strong>hookName</strong> 把全流程就串起来了！最终得到全流程如下：</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>compiler -&gt; environment
compiler -&gt; afterEnvironment
compiler -&gt; entryOption
compiler -&gt; afterPlugins
compiler -&gt; afterResolvers
compiler -&gt; beforeRun
compiler -&gt; run
compiler -&gt; normalModuleFactory
compiler -&gt; contextModuleFactory
compiler -&gt; beforeCompile
compiler -&gt; compile
compiler -&gt; thisCompilation
compiler -&gt; compilation
compiler -&gt; make
    compilation -&gt; addEntry
    compilation -&gt; buildModule
    compilation -&gt; normalModuleLoader
    compilation -&gt; succeedModule
    compilation -&gt; buildModule
    compilation -&gt; normalModuleLoader
    compilation -&gt; succeedModule
    compilation -&gt; succeedEntry
    compilation -&gt; finishModules
    compilation -&gt; seal
    compilation -&gt; optimizeDependenciesBasic
    compilation -&gt; optimizeDependencies
    compilation -&gt; optimizeDependenciesAdvanced
    compilation -&gt; afterOptimizeDependencies
    compilation -&gt; beforeChunks
    compilation -&gt; dependencyReference
    compilation -&gt; afterChunks
    compilation -&gt; optimize
    compilation -&gt; optimizeModulesBasic
    compilation -&gt; optimizeModules
    compilation -&gt; optimizeModulesAdvanced
    compilation -&gt; afterOptimizeModules
    compilation -&gt; optimizeChunksBasic
    compilation -&gt; optimizeChunks
    compilation -&gt; optimizeChunksAdvanced
    compilation -&gt; afterOptimizeChunks
    compilation -&gt; optimizeTree
    compilation -&gt; afterOptimizeTree
    compilation -&gt; optimizeChunkModulesBasic
    compilation -&gt; optimizeChunkModules
    compilation -&gt; optimizeChunkModulesAdvanced
    compilation -&gt; afterOptimizeChunkModules
    compilation -&gt; shouldRecord
    compilation -&gt; reviveModules
    compilation -&gt; optimizeModuleOrder
    compilation -&gt; advancedOptimizeModuleOrder
    compilation -&gt; beforeModuleIds
    compilation -&gt; moduleIds
    compilation -&gt; optimizeModuleIds
    compilation -&gt; afterOptimizeModuleIds
    compilation -&gt; reviveChunks
    compilation -&gt; optimizeChunkOrder
    compilation -&gt; beforeChunkIds
    compilation -&gt; optimizeChunkIds
    compilation -&gt; afterOptimizeChunkIds
    compilation -&gt; recordModules
    compilation -&gt; recordChunks
    compilation -&gt; beforeHash
    compilation -&gt; chunkHash
    compilation -&gt; contentHash
    compilation -&gt; afterHash
    compilation -&gt; recordHash
    compilation -&gt; beforeModuleAssets
    compilation -&gt; shouldGenerateChunkAssets
    compilation -&gt; beforeChunkAssets
    compilation -&gt; chunkAsset
    compilation -&gt; additionalChunkAssets
    compilation -&gt; record
    compilation -&gt; additionalAssets
    compilation -&gt; optimizeChunkAssets
    compilation -&gt; afterOptimizeChunkAssets
    compilation -&gt; optimizeAssets
    compilation -&gt; afterOptimizeAssets
    compilation -&gt; needAdditionalSeal
    compilation -&gt; afterSeal
compiler -&gt; afterCompile
compiler -&gt; shouldEmit
compiler -&gt; emit
compiler -&gt; afterEmit
    compilation -&gt; needAdditionalPass
compiler -&gt; done
</code></pre></div><p>为了更好理解 <strong>compiler</strong> 和 <strong>Compilation</strong> 的区别，再将<code>webpack.config.js</code>修改下，增加watch配置，这样只要 <strong>entry</strong> 文件修改过，就会重新启动一次编译。我们来看下 watch 编译的流程和第一次编译流程有什么区别：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// webpack.config.js</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
    mode<span class="token punctuation">:</span> <span class="token string">'development'</span><span class="token punctuation">,</span>
    devtool<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
    <span class="token comment">// 下面是只有一个entry的情况</span>
    <span class="token comment">// 没有output则默认输出是到dist的main</span>
    entry<span class="token punctuation">:</span> <span class="token string">'./src/app.js'</span><span class="token punctuation">,</span>
    <span class="token comment">// 增加watch功能</span>
    watch<span class="token punctuation">:</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>这时候执行<code>webpack --config webpack.config.js</code>，第一次编译触发，然后修改下app.js，通过 watch 监控，发生了第二次编译，得到下面的输出：</p> <div class="language- extra-class"><pre class="language-text"><code>compiler -&gt; invalid
compiler -&gt; watchRun
compiler -&gt; normalModuleFactory
compiler -&gt; contextModuleFactory
compiler -&gt; beforeCompile
compiler -&gt; compile
compiler -&gt; thisCompilation
compiler -&gt; compilation
compiler -&gt; make
    compilation -&gt; addEntry
    compilation -&gt; buildModule
    compilation -&gt; normalModuleLoader
    compilation -&gt; succeedModule
    compilation -&gt; succeedEntry
    compilation -&gt; finishModules
    compilation -&gt; seal
    compilation -&gt; optimizeDependenciesBasic
    compilation -&gt; optimizeDependencies
    compilation -&gt; optimizeDependenciesAdvanced
    compilation -&gt; afterOptimizeDependencies
    compilation -&gt; beforeChunks
    compilation -&gt; dependencyReference
    compilation -&gt; afterChunks
    compilation -&gt; optimize
    compilation -&gt; optimizeModulesBasic
    compilation -&gt; optimizeModules
    compilation -&gt; optimizeModulesAdvanced
    compilation -&gt; afterOptimizeModules
    compilation -&gt; optimizeChunksBasic
    compilation -&gt; optimizeChunks
    compilation -&gt; optimizeChunksAdvanced
    compilation -&gt; afterOptimizeChunks
    compilation -&gt; optimizeTree
    compilation -&gt; afterOptimizeTree
    compilation -&gt; optimizeChunkModulesBasic
    compilation -&gt; optimizeChunkModules
    compilation -&gt; optimizeChunkModulesAdvanced
    compilation -&gt; afterOptimizeChunkModules
    compilation -&gt; shouldRecord
    compilation -&gt; reviveModules
    compilation -&gt; optimizeModuleOrder
    compilation -&gt; advancedOptimizeModuleOrder
    compilation -&gt; beforeModuleIds
    compilation -&gt; moduleIds
    compilation -&gt; optimizeModuleIds
    compilation -&gt; afterOptimizeModuleIds
    compilation -&gt; reviveChunks
    compilation -&gt; optimizeChunkOrder
    compilation -&gt; beforeChunkIds
    compilation -&gt; optimizeChunkIds
    compilation -&gt; afterOptimizeChunkIds
    compilation -&gt; recordModules
    compilation -&gt; recordChunks
    compilation -&gt; beforeHash
    compilation -&gt; chunkHash
    compilation -&gt; contentHash
    compilation -&gt; afterHash
    compilation -&gt; recordHash
    compilation -&gt; beforeModuleAssets
    compilation -&gt; shouldGenerateChunkAssets
    compilation -&gt; beforeChunkAssets
    compilation -&gt; chunkAsset
    compilation -&gt; additionalChunkAssets
    compilation -&gt; record
    compilation -&gt; additionalAssets
    compilation -&gt; optimizeChunkAssets
    compilation -&gt; afterOptimizeChunkAssets
    compilation -&gt; optimizeAssets
    compilation -&gt; afterOptimizeAssets
    compilation -&gt; needAdditionalSeal
    compilation -&gt; afterSeal
compiler -&gt; afterCompile
compiler -&gt; shouldEmit
compiler -&gt; emit
compiler -&gt; afterEmit
    compilation -&gt; needAdditionalPass
compiler -&gt; done
</code></pre></div><p>通过上面输出的内容可以发现，<code>compiler</code> 只是从<code>invalid -&gt; watchRun</code> 开始，没有重新走流程，而compilation却是走了一个完整的流程，所以我们更好地理解了：<strong>compiler 是管理整个生命周期的，而 compilation 是每次编译触发都会重新生成一次的</strong>。</p> <blockquote><p><em><strong>Tips:</strong></em> 当处于监听模式时，compiler 会触发诸如 watchRun, watchClose 和 invalid 等额外的事件，这个跟普通模式下的流程稍有不同，主要区别在下面的内容：</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code> # 普通模式
 compiler -&gt; afterResolvers
 compiler -&gt; beforeRun （不同）
 compiler -&gt; run （不同）
 compiler -&gt; normalModuleFactory
 
 # watch模式
 compiler -&gt; afterResolvers
 compiler -&gt; watchRun （不同）
 compiler -&gt; normalModuleFactory
</code></pre></div><h2 id="总结"><a href="#总结" aria-hidden="true" class="header-anchor">#</a> 总结</h2> <p>本小节主要是结合之前的 Webpack 内核知识，来讲解一次打包的过程 Webpack 做的事情有哪些。Webpack 打包流程从配置文件的读取开始，分别经过了准备阶段、modules 产出阶段、chunks 产出阶段和 bundle 产出物产出阶段。在各自阶段，分别有不同的「角色」参与，整个 Webpack 的打包流程是通过 Compiler 来控制的，而每次打包的过程是通过 Compilation 来控制的。在普通打包模式下，webpack 的 Compiler 和 Compilation 是一一对应的关系； watch 模式下，Webpack 的 Compiler 会因为文件变化而产生多次打包流程，所以 Compiler 和 Compilation 是一对多关系，通过 Hook Compiler 的流程，可以得到每次打包过程的回调。</p> <p>本小节知识量较大，所以继续总结下 webpack 工作流程中涉及到的类（对象）的作用，我们也可以从这些对象的角度来梳理和记忆 Webpack 的工作流程：</p> <ul><li>Tapbale：Webpack 事件流程核心类；</li> <li>Compiler：Webpack 工作流程中最高层的对象，初始化配置，提供 Webpack 流程的全局钩子，比如done、compilation这类；</li> <li>Compilation：由 Compiler 来创建的实例对象，是每次打包流程最核心的流程，该对象内进行模块依赖解析、优化资源、渲染 runtime 代码等事情，下面在 Compilation 中还有用到的一些对象：</li> <li>Resolver：解析模块（module）、loader 等路径，帮助查找对应的位置；</li> <li>ModuleFactory：负责构造模块的实例，将 Resolver 解析成功的组件中把源码从文件中读取出来，然后创建模块对象；</li> <li>Template：主要是来生成 runtime 代码，将解析后的代码按照依赖顺序处理之后，套上 Template 就是我们最终打包出来的代码。</li></ul> <p><strong>本小节 Webpack 相关面试题：</strong></p> <ol><li>能否说下 Webpack 的完整打包流程，从读取配置到输出文件这个过程尽量说全？</li> <li>介绍几个你了解过的 Webpack 中的类，有什么用？</li></ol></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">9/14/2019, 2:07:17 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/0025.html" class="prev">25 Webpack 的 Compiler 和 Compilation</a></span> <span class="next"><a href="/0027.html">27 从 Webpack 的产出代码来看 Webpack 是怎么执行的</a>→
    </span></p></div> </main></div><div class="global-ui"><SWUpdatePopup></SWUpdatePopup></div></div>
    <script src="/assets/js/app.745025a3.js" defer></script><script src="/assets/js/2.d6c01b35.js" defer></script><script src="/assets/js/31.48156b6a.js" defer></script>
  </body>
</html>
