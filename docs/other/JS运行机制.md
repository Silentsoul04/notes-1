---
title: JS运行机制
description: 
lang: zh-CN
---

1. 在JS的执行过程中同步任务优先执行，同步任务执行之后才会去执行异步任务
2. JS是单线程的，从上往下的执行过程中会遇到同步和异步的任务，例如 `console.log` 就是一个同步任务，`element.onClick = function(){}` 就是一个异步任务。当遇到同步的代码后，会将任务添加到运行栈中，异步任务会添加到任务队列中。当运行栈中的同步任务全部执行完成之后，才会去遍历任务队列查找是否存在可以执行异步任务，如果存在的话，会将这个异步任务推入运行栈进行执行。当浏览器执行到 `setTiomeout` 和 `setInterval` 代码时，并不会立刻将 `setTiomeout` 和 `setInterval` 添加到任务队列，此时 `setTiomeout` 和 `setInterval` 会交给浏览器的 `timer` 模块，当时间到了之后会将 `setTiomeout` 和 `setInterval` 的内容推入任务队列，在 `Event Loop` 的过程中被执行。

3. 那些语句会被添加到任务队列 `setTimeout` 和 `setInterval` ，DOM 事件，ES6 的 Promise。

## 一段JS代码是如何被执行的

JS 的执行分为创建阶段和执行阶段。

创建阶段，在代码执行前，JS 引擎会先创建一个执行栈，然后在创建一个全局的执行上下文，并 push 进执行栈，在这个过程中 JS 引擎会为这段代码中所有变量分配内存并给一个初始值 undefined，这也就是我们常说的 **变量提升**。

创建完成后 JS 引擎就会进入执行阶段，这个过程 JS 引擎会逐行的执行代码，为之前分配好内存的变量逐个赋值（真实值）。

如果这段代码中存在 function 的声明和调用，JS 引擎会创建一个函数执行上下文，并 push 进执行栈，它的创建和执行过程与全局执行上文一样。但如果这个函数中存在对其他函数的调用时，JS 引擎会在父函数的执行过程中，将子函数的执行上下文 push 进执行栈，这也是为什么子函数可以访问父函数内所声明的变量。（相当于在父函数中定义了子函数，父函数执行过程中会将子函数上下文 push 进执行栈）

对于闭包，父函数 return 了一个子函数，子函数执行的时候，父函数已经 return 了(子函数执行的时候父函数早就执行完了)。这种场景，JS 引擎会将父函数的上下文从执行栈中移除，父函数上下文被移除的同时，JS 引擎会为尚未执行或还在执行过程中的子函数上下文创建一个闭包，这个闭包内保存了父函数内声明的变量及其赋值，子函数仍然能够在其上下文中访问并使用这个变量。当子函数执行结束，JS 引擎才会将子函数的上下文及闭包一并从执行栈移除。

高并发，例如 Promise.all ，当异步任务被触发，会将异步任务 push 进执行栈，执行过程中对于需要异步执行的代码，会移出执行栈 push 进任务队列，继续执行下一个异步任务以此循环，当执行栈中已经没有需要被执行的代码了，JS 引擎回去遍历任务队列，等之前的请求回来了，立刻将任务队列中的回调 push 进执行栈执行。

## common.js 和 ES Module 的区别

CommonJs 是一种模块化规范，最初被应用与 NodeJs，成为 Nodejs 的模块化规范。运行在浏览器端的 JS 由于也缺少类似的规范，在 ES6 出来前，前端也实现了一套类型的模块化规范（AMD、UMD...）。自 ES6 起，引入了一套新的 ES6 Module 规范，在语言标准层面实现了模块功能，右往成为浏览器和服务器通用的模块解决方案。但目前浏览器对 ES6 Module 兼容还不太友好，所以平时在 webpack 中使用的 export 和 import ，会经过 Babel 转换为 CommonJs 规范。

- CommonJs 模块输出的是一个值得拷贝，ES6 模块输出的是一个值得引用。
- CommonJs 模块是运行时加载，ES6 模块是编译时输出接口。
- CommonJs 是单个值的导出，ES6 Module 可以导出多个。
- CommonJs **是动态语法** 可以写在判断中，ES6 Module **是静态语法** 只能写在顶层。
- CommonJs 得 this 指向当前模块，ES6 Module 得 this 是 undefined。

## Virtual Dom 的优势在哪里

DOM 引擎、JS 引擎相互独立，但又工作在同一线程（主线程）JS 代码调用 DOM API 后，必须挂起 JS 引擎、转换传入参数数据、激活 DOM 引擎，DOM 重绘后在转换可能有的返回值，最后激活 JS 引擎并继续执行，若有 DOM API 调用，且浏览器厂商不做”批量处理“的优化，引擎间切换的单位代价将迅速累积，若其中有强制重绘的 DOM API 调用，重排重绘会引起更大的性能消耗。

- Virtual Dom 不会立刻进行重排与重绘的操作。
- Virtual Dom 进行频繁更改，然后一次性比较并修改真实 DOM 中需要更改的部分，最后在真实 DOM 进行重排重绘，减少过多的 DOM 操作。
- Virtual Dom 有效降低大面积真实 DOM 的重绘重排，因为最终与真实 DOM 比较差异，可以只渲染局部。